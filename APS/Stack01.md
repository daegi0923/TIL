# 240207_Stack01_1

# 스택

## 스택(stack)의 특성

- 자료를 쌓아 올린 형태의 자료구조
- 스택에 저장된 자료는 선형 구조
    - 선형구조 : 자료 간의 관계가 1대1의 관계를 가짐
    - 비선형구조 : 자료 간의 관계가 1대N의 관계를 가짐
- 마지막에 삽입한 자료를 가장 먼저 꺼냄 LIFO(Last-In-First-Out)

### 구현에 필요한 자료구조 & 연산

- 자료구조 : 자료를 선형으로 저장할 저장소
    - 배열 사용가능
    - 저장소 자체를 스택이라 부르기도 함
    - 마지막 삽입된 원소의 위치를 top이라 함
- 연산
    - 삽입 : 저장소에 자료 저장. push
    - 삭제 : 저장소에서 자료를 꺼냄. pop
    - 스택이 공백인지 확인하는 연산. isEmpty
    - 스택의 top에 있는 원소를 반환하는 연산. peek

### 스택의 삽입/삭제 과정

- 빈 스택에 원소 A, B, C를 차례로 삽입 후 한번 삭제하는 연산과정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3efa4bec-a626-4de9-89ed-a2a1b3da7df0/ee0e59f1-bb39-4fae-8ec1-f857118c637c/Untitled.png)

### 스택의 push 알고리즘

- append 메소드를 통해 리스트의 마지막에 데이터를 삽입

```python
def push(item):
		s.append(item)
```

### 스택의 pop 알고리즘

```python
def pop():
		if len(s) == 0:
				#underflow
				return
		else:
				return s.pop();
```

---

# 스택의 응용

## 괄호검사

- 괄호의 종류 : 대괄호[], 중괄호{}, 소괄호()
- 조건
    - 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
    - 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
    - 괄호 사이에는 포함 관계만 존재한다.

## function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
    - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입 선출 구조
    - ⇒ 스택을 이용하여 수행순서 관리

---

# Memoization

- 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술

```python
def fibo1(n):
    global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]

n = 10

memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
fibo1(n)
print(memo)
```

---

### 자료구조

1. 선형구조
2. 비선형구조
3. 파일

### 코드를 잘 짰는지 생각

1. 무한대로 늘려봐
2. 뒤집어봐라
3. 외곽을 늘려서봐라(이게뭔데 ㅋㅋ)

### 조건문

- 조건문은 더 적은 경우를 if로 걸어서 위로 올리
- else에 올게 예상이 안된데이 ㅋㅋ

파이썬에서 bool + int 하면 int로 형변환되더라 ㅋㅋ


---
# 240208_Stack02_2
## DP(Dynamic Programming)
- 동적 계획(Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
- 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결

- 피보나치 수 DP 적용 알고리즘
```python
def fibo2(n):
    f = [0] * (n+1)
    f[0] = 0
    f[1] = 1
    for i in range(2, n+1):
        f[i] = f[i-1] + f[i-2]

    return f[n]

```
### DP의 구현 방식
- memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다.
- 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문.

## DFS(깊이우선탐색)
- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함.
- 두가지 방법
    1. DFS(깊이 우선 탐색)
    2. BFS(너비 우선 탐색)
- 스택을 활용할 수도 있는것(DFS는 스택을 활용한 탐색 => 이말은 틀렸대)
1. 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳 까지 깊이 탐색
2. 더 갈 곳이 없게되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색 반복
3. 모든 정점을 순회
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

### DFS 알고리즘
1. 시작 정점 v를 결정하여 방문한다.
1. 정점 v에 인접한 정점 중에서
    1. 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push, 정점 w 방문
    1. 방문하지 않은 정점이 없으면, 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복
1. 스택이 공백이 될때까지 2)를 반복
